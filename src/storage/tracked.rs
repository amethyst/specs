use std::iter::Enumerate;
use std::marker::PhantomData;
use std::ops::{Deref, DerefMut};
use std::slice;

use hibitset::{BitSet, BitSetLike};

use {Component, DenseVecStorage, Index, MaskedStorage, Storage, UnprotectedStorage};

/// This enum represents the different changes the `TrackedStorage`
/// can detect.
///
/// ## Resets
///
/// You most likely want to reset the `TrackedStorage` every frame.
/// By doing that, all change events are cleared.
///
/// ## Maintain
///
/// By maintaining the `FlaggedStorage`, the inner storage and the cache
/// will be searched for unequal elements, generating `Modified` events for those.
///
/// ## Frames
///
/// In the following, the term "frame" will be used to describe
/// the timeframe between a reset and an eventual maintain.
/// (eventual maintain because you may not be interested in `Modified` events)
///
/// ## Which event will be generated?
///
/// This section explains some edge cases.
///
/// ### There are no insertions, no removals, no maintained changes
///
/// No event (`None`)
///
/// ### There has been one insertion but also one removal in this frame
///
/// Because the change has been reverted, there's no event (`None`)
///
/// ### There has been a removal and an insertion in this frame
///
/// This is the only case where a `Modified` event will be generated
/// without a call to `maintain`.
///
/// ### A component has been inserted and modified later in this frame (maintained)
///
/// The insertion has the bigger priority (`Inserted`).
///
/// ### A component has been modified and then removed
///
/// The removal has priority over the modification (`Removed`).
#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
pub enum Change {
    /// The component didn't change.
    None,
    /// A component has been inserted.
    Inserted,
    /// The component has been modified.
    Modified,
    /// The component has been removed.
    Removed,
}

impl Change {
    fn add(&mut self, change: Change) {
        use Change::*;

        let new = match (*self, change) {
            (None, new) => new,
            (Inserted, Modified) => Inserted,
            (Inserted, Removed) => None,
            (Modified, Modified) => Modified,
            (Modified, Removed) => Removed,
            (Removed, Inserted) => Modified,
            (old, new) => panic!("Didn't expect change from {:?} to {:?}", old, new),
        };

        *self = new;
    }
}

/// Events iterator for all events between the last reset and the last,
/// eventual maintain. See `Change` docs for more explanations.
pub struct ChangeEvents<'a> {
    inner: Enumerate<slice::Iter<'a, Change>>,
}

impl<'a> Iterator for ChangeEvents<'a> {
    type Item = (Index, Change);

    fn next(&mut self) -> Option<Self::Item> {
        self.inner
            .find(|&(_, &c)| c != Change::None)
            .map(|(id, &c)| (id as Index, c))
    }
}

impl<'e, S, T, D> Storage<'e, T, D>
where
    S: UnprotectedStorage<T> + Send + Sync + 'static,
    T: Component<Storage = TrackedStorage<T, S>> + Clone + Send + Sync,
    D: Deref<Target = MaskedStorage<T>>,
{
    /// Returns the change events generated by the `TrackedStorage`.
    /// See `Change` for more explanations.
    /// The elements are mapped to entity indices, that means the `Change`
    /// for entity with id `5` will be the 6th element of this slice.
    ///
    /// ## Examples
    ///
    /// ```
    /// use specs::{Change, Component, TrackedStorage, World};
    ///
    /// #[derive(Clone, PartialEq)] // `PartialEq` is only necessary for maintain
    /// struct Comp(u8);
    ///
    /// impl Component for Comp {
    ///     // Will use `DenseVecStorage` by default.
    ///     type Storage = TrackedStorage<Self>;
    /// }
    ///
    /// let mut w = World::new();
    /// w.register::<Comp>();
    ///
    /// let a = w.create_entity().with(Comp(1)).build();
    ///
    /// let change = w.read::<Comp>().change_events_tracked()[a.id() as usize];
    /// assert_eq!(change, Change::Inserted);
    /// ```
    pub fn change_events_tracked(&self) -> &[Change] {
        self.data.inner.change_events()
    }
}

impl<'e, S, T, D> Storage<'e, T, D>
where
    S: UnprotectedStorage<T> + Send + Sync + 'static,
    T: Component<Storage = TrackedStorage<T, S>> + Clone + Send + Sync,
    D: DerefMut<Target = MaskedStorage<T>>,
{
    /// Maintains the `TrackedStorage`.
    ///
    /// You can only call this in case your component implements `PartialEq`.
    /// This will compare the cache with the current storage and generate change events
    /// in case the `PartialEq` implementation says that two components are different.
    ///
    /// If you don't care about `Change::Modified` events, you don't have to call this method.
    ///
    /// ## When should I call this method?
    ///
    /// You should make sure that it gets called before you need the information which component
    /// has been modified. E.g. in case you have several systems writing to the component, then
    /// several reading from it, you can just call `maintain_tracked` once in between.
    pub fn maintain_tracked(&mut self)
    where
        T: PartialEq,
    {
        let (set, inner) = self.data.open_mut();
        unsafe {
            inner.maintain(set);
        }
    }

    /// Resets the tracked storage. This clears all change events.
    /// You most likely want to do this at the end of every frame.
    pub fn reset_tracked(&mut self) {
        let (set, inner) = self.data.open_mut();
        unsafe {
            inner.reset(set);
        }
    }
}

/// Storage which tracks changes.
#[derive(Derivative)]
#[derivative(Default(bound = "S: Default"))]
pub struct TrackedStorage<C, S = DenseVecStorage<C>> {
    changes: Vec<Change>,
    _marker: PhantomData<C>,
    old: S,
    storage: S,
}

impl<C, S> TrackedStorage<C, S>
where
    C: Clone,
    S: UnprotectedStorage<C>,
{
    /// Returns a slice for all change events.
    /// The elements are in entity order, that means the `Change`
    /// for entity with id `5` will be the 6th element of this slice.
    pub fn change_events(&self) -> &[Change] {
        &self.changes
    }

    /// Resets the `TrackedStorage`.
    pub unsafe fn reset(&mut self, set: &BitSet) {
        for id in set {
            let elem = self.old.get_mut(id);
            *elem = self.storage.get(id).clone();
        }

        self.changes.iter_mut().for_each(|c| *c = Change::None);
    }

    fn insert_change(changes: &mut Vec<Change>, id: Index, val: Change) {
        use std::cmp::max;
        use std::iter::repeat;

        let ind = id as usize;
        let len = changes.len();
        changes.extend(repeat(Change::None).take(max(ind + 1, len) - len));

        changes[ind].add(val);
    }
}

impl<C, S> TrackedStorage<C, S>
where
    C: Clone + PartialEq,
    S: UnprotectedStorage<C>,
{
    /// Maintains the `TrackedStorage`
    pub unsafe fn maintain(&mut self, set: &BitSet) {
        let TrackedStorage {
            ref old,
            ref storage,
            ref mut changes,
            ..
        } = *self;

        set.iter()
            .filter(|id| old.get(*id) != storage.get(*id))
            .for_each(|id| Self::insert_change(changes, id, Change::Modified))
    }
}

impl<C, S> UnprotectedStorage<C> for TrackedStorage<C, S>
where
    C: Clone,
    S: UnprotectedStorage<C>,
{
    unsafe fn clean<B>(&mut self, has: B)
    where
        B: BitSetLike,
    {
        self.old.clean(&has);
        self.storage.clean(&has);
    }

    unsafe fn get(&self, id: Index) -> &C {
        self.storage.get(id)
    }

    unsafe fn get_mut(&mut self, id: Index) -> &mut C {
        self.storage.get_mut(id)
    }

    unsafe fn insert(&mut self, id: Index, value: C) {
        Self::insert_change(&mut self.changes, id, Change::Inserted);

        self.old.insert(id, value.clone());
        self.storage.insert(id, value);
    }

    unsafe fn remove(&mut self, id: Index) -> C {
        Self::insert_change(&mut self.changes, id, Change::Removed);

        self.old.remove(id);
        self.storage.remove(id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use World;

    #[derive(Clone, PartialEq)]
    struct Comp(u8);

    impl Component for Comp {
        type Storage = TrackedStorage<Self>;
    }

    fn world() -> World {
        let mut world = World::new();
        world.register::<Comp>();

        world
    }

    fn maint(w: &World) {
        w.write::<Comp>().maintain_tracked();
    }

    fn reset(w: &World) {
        w.write::<Comp>().reset_tracked();
    }

    macro_rules! ev_eq {
        ( $w:ident => $( $ent:ident : $change:expr )* ) => {
            {
                let comps = $w .read::<Comp>();
                assert_eq!(
                    comps
                        .change_events_tracked()
                        .iter()
                        .cloned()
                        .enumerate()
                        .filter(|&(_, c)| c != Change::None)
                        .collect::<Vec<_>>(),
                    vec![$( ( $ent .id() as usize , $change ), )*]
                );
            }
        };
    }

    #[test]
    fn insert() {
        let mut w = world();
        ev_eq!(w =>);

        let a = w.create_entity().with(Comp(1)).build();
        ev_eq!(w => a: Change::Inserted);
    }

    #[test]
    fn modified() {
        let mut w = world();
        let w = &mut w;
        ev_eq!(w =>);

        let a = w.create_entity().with(Comp(1)).build();
        ev_eq!(w => a: Change::Inserted);

        w.write().insert(a, Comp(2));
        ev_eq!(w => a: Change::Inserted);

        maint(w);
        ev_eq!(w => a: Change::Inserted);

        reset(w);
        ev_eq!(w =>);

        w.write().insert(a, Comp(4));
        maint(w);
        ev_eq!(w => a: Change::Modified);
    }

    #[test]
    fn removed_entity() {
        let mut w = world();
        let w = &mut w;

        let a = w.create_entity().with(Comp(0)).build();
        reset(w);
        ev_eq!(w =>);

        w.delete_entity(a).unwrap();
        ev_eq!(w => a: Change::Removed);
    }

    #[test]
    fn removed_entity_atomic() {
        let mut w = world();
        let w = &mut w;

        let a = w.create_entity().with(Comp(0)).build();
        reset(w);
        ev_eq!(w =>);

        w.entities().delete(a).unwrap();
        ev_eq!(w => );

        w.maintain();
        ev_eq!(w => a: Change::Removed);
    }

    #[test]
    fn removed_component() {
        let mut w = world();
        let w = &mut w;

        let a = w.create_entity().with(Comp(0)).build();
        reset(w);
        ev_eq!(w =>);

        w.write::<Comp>().remove(a);
        ev_eq!(w => a: Change::Removed);
    }

    #[test]
    fn remove_insert_mix() {
        let mut w = world();
        let w = &mut w;

        let a = w.create_entity().with(Comp(0)).build();
        reset(w);
        ev_eq!(w =>);

        w.write::<Comp>().remove(a);
        ev_eq!(w => a: Change::Removed);

        w.write::<Comp>().insert(a, Comp(1));
        maint(w);
        ev_eq!(w => a: Change::Modified);

        w.write::<Comp>().remove(a);
        ev_eq!(w => a: Change::Removed);

        reset(w);
        let b = w.create_entity().with(Comp(5)).build();
        ev_eq!(w => b: Change::Inserted);

        w.delete_entity(b).unwrap();
        ev_eq!(w =>);
    }
}
